"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimatedKeyboardHandler = useAnimatedKeyboardHandler;
exports.useSharedHandlers = useSharedHandlers;

var _react = require("react");

var _reactNativeReanimated = require("react-native-reanimated");

function useAnimatedKeyboardHandler(handlers, dependencies) {
  const {
    context,
    doDependenciesDiffer
  } = (0, _reactNativeReanimated.useHandler)(handlers, dependencies);
  return (0, _reactNativeReanimated.useEvent)(event => {
    'worklet';

    const {
      onKeyboardMoveStart,
      onKeyboardMove,
      onKeyboardMoveEnd
    } = handlers;

    if (onKeyboardMoveStart && event.eventName.endsWith('onKeyboardMoveStart')) {
      onKeyboardMoveStart(event, context);
    }

    if (onKeyboardMove && event.eventName.endsWith('onKeyboardMove')) {
      onKeyboardMove(event, context);
    }

    if (onKeyboardMoveEnd && event.eventName.endsWith('onKeyboardMoveEnd')) {
      onKeyboardMoveEnd(event, context);
    }
  }, ['onKeyboardMoveStart', 'onKeyboardMove', 'onKeyboardMoveEnd'], doDependenciesDiffer);
}
/**
 * Hook for storing worklet handlers (objects with keys, where values are worklets).
 * Returns methods for setting handlers and broadcasting events in them.
 *
 * T is a generic that looks like:
 * @example
 * {
 *  onEvent: () => {},
 *  onEvent2: () => {},
 * }
 */


function useSharedHandlers() {
  const handlers = (0, _reactNativeReanimated.useSharedValue)({});
  const jsHandlers = (0, _react.useRef)({}); // since js -> worklet -> js call is asynchronous, we can not write handlers
  // straight into shared variable (using current shared value as a previous result),
  // since there may be a race condition in a call, and closure may have out-of-dated
  // values. As a result, some of handlers may be not written to "all handlers" object.
  // Below we are writing all handlers to `ref` and afterwards synchronize them with
  // shared value (since `refs` are not referring to actual value in worklets).
  // This approach allow us to update synchronously handlers in js thread (and it assures,
  // that it will have all of them) and then update them in worklet thread (calls are
  // happening in FIFO order, so we will always have actual value).

  const updateSharedHandlers = () => {
    handlers.value = jsHandlers.current;
  };

  const setHandlers = (0, _react.useCallback)(handler => {
    jsHandlers.current = { ...jsHandlers.current,
      ...handler
    };
    updateSharedHandlers();
  }, []);

  const broadcast = (type, event) => {
    'worklet';

    Object.keys(handlers.value).forEach(key => {
      var _handlers$value$key, _handlers$value$key$t;

      return (_handlers$value$key = handlers.value[key]) === null || _handlers$value$key === void 0 ? void 0 : (_handlers$value$key$t = _handlers$value$key[type]) === null || _handlers$value$key$t === void 0 ? void 0 : _handlers$value$key$t.call(_handlers$value$key, event);
    });
  };

  return {
    setHandlers,
    broadcast
  };
}
//# sourceMappingURL=internal.js.map